import { NextRequest, NextResponse } from "next/server";
import Replicate from "replicate";

export const dynamic = 'force-dynamic';

// Using Pollinations.ai with Flux model - FREE and BEST QUALITY for NFTs
// Flux is currently the state-of-the-art free AI model for high-quality image generation

export async function POST(req: NextRequest) {
  let requestBody;
  
  try {
    // Try to parse JSON with better error handling
    requestBody = await req.json();
  } catch (parseError) {
    console.error('JSON parsing error in API route:', parseError);
    return NextResponse.json(
      {
        error: "Invalid JSON in request body",
        details: "Please check your request format",
        message: "Request body contains invalid JSON"
      },
      { status: 400 }
    );
  }

  try {
    const { pfpUrl, username, taBalance, casts } = requestBody;

    console.log('NFT generation request:', { username, hasPfp: !!pfpUrl, castsCount: casts?.length || 0 });

    if (!username) {
      return NextResponse.json(
        { error: "Username required" },
        { status: 400 }
      );
    }

    // Advanced cast analysis for personalized character design
    let castContext = "";
    let userVoice = "";
    let userInterests: string[] = [];
    let userPersonality = "";
    
    if (casts && Array.isArray(casts) && casts.length > 0) {
      // Analyze all casts (up to 10) for deeper insights
      const allCastTexts = casts.slice(0, 10).map((cast: any) => cast.text || cast.content || "").filter(Boolean);
      const recentCastTexts = casts.slice(0, 5).map((cast: any) => cast.text || cast.content || "").filter(Boolean);
      
      if (allCastTexts.length > 0) {
        // Extract key themes and topics
        const fullText = allCastTexts.join(" ").toLowerCase();
        
        // Detect interests based on keywords
        const interestKeywords: { [key: string]: string[] } = {
          crypto: ['crypto', 'bitcoin', 'ethereum', 'defi', 'nft', 'blockchain', 'web3', 'token', 'dao'],
          science: ['science', 'research', 'study', 'experiment', 'data', 'analysis', 'hypothesis', 'theory', 'discovery'],
          tech: ['ai', 'machine learning', 'code', 'software', 'developer', 'programming', 'tech', 'algorithm'],
          art: ['art', 'design', 'creative', 'aesthetic', 'visual', 'illustration', 'artist'],
          philosophy: ['philosophy', 'think', 'thought', 'idea', 'concept', 'meaning', 'existential'],
          health: ['health', 'medicine', 'medical', 'wellness', 'bio', 'biology', 'life'],
          space: ['space', 'cosmos', 'universe', 'astronomy', 'planet', 'star', 'galaxy'],
          gaming: ['game', 'gaming', 'play', 'player', 'quest', 'level', 'character'],
        };
        
        for (const [interest, keywords] of Object.entries(interestKeywords)) {
          if (keywords.some(keyword => fullText.includes(keyword))) {
            userInterests.push(interest);
          }
        }
        
        // Analyze writing style/voice
        const avgLength = allCastTexts.reduce((sum, text) => sum + text.length, 0) / allCastTexts.length;
        const hasQuestions = allCastTexts.some(text => text.includes('?'));
        const hasEmojis = allCastTexts.some(text => /[\u{1F300}-\u{1F9FF}]/u.test(text));
        const isTechnical = fullText.includes('code') || fullText.includes('tech') || fullText.includes('algorithm');
        const isPhilosophical = fullText.includes('think') || fullText.includes('idea') || fullText.includes('meaning');
        const isCreative = fullText.includes('art') || fullText.includes('design') || fullText.includes('creative');
        
        // Build personality profile
        if (isTechnical && isPhilosophical) {
          userPersonality = "a deep-thinking technologist and philosopher";
        } else if (isTechnical) {
          userPersonality = "a technical innovator and builder";
        } else if (isPhilosophical) {
          userPersonality = "a thoughtful philosopher and intellectual";
        } else if (isCreative) {
          userPersonality = "a creative visionary and artist";
        } else {
          userPersonality = "a unique individual with distinct perspectives";
        }
        
        // Build voice description
        if (avgLength > 200) {
          userVoice += "detailed and expressive";
        } else if (avgLength < 50) {
          userVoice += "concise and impactful";
        } else {
          userVoice += "balanced and thoughtful";
        }
        
        if (hasQuestions) {
          userVoice += ", curious and inquisitive";
        }
        
        // Build context from recent casts
        const contextTexts = recentCastTexts.slice(0, 3).join(". ");
        castContext = `This person is ${userPersonality} with a ${userVoice} voice. `;
        
        if (userInterests.length > 0) {
          castContext += `Their interests include: ${userInterests.slice(0, 3).join(", ")}. `;
        }
        
        if (contextTexts) {
          castContext += `Recent thoughts and content: "${contextTexts.substring(0, 300)}". `;
        }
      }
    }

    // Generate personalized traits based on user data
    const generateTraits = () => {
      const traits = [];
      const rarities = ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic"];
      
      // EPIC HYPE Core personality traits based on cast analysis
      if (userPersonality.includes("technical")) {
        traits.push({ trait_type: "üöÄ Primary Specialty", value: "Quantum Technomancer Supreme", rarity: "Mythic" });
        traits.push({ trait_type: "‚ö° Ultimate Power", value: "Reality Data Hacking Master", rarity: "Mythic" });
      }
      if (userPersonality.includes("philosophical")) {
        traits.push({ trait_type: "üß† Specialty", value: "Consciousness Architect Alpha", rarity: "Legendary" });
        traits.push({ trait_type: "üåå Primary Power", value: "Temporal Consciousness Access Supreme", rarity: "Mythic" });
      }
      if (userPersonality.includes("creative")) {
        traits.push({ trait_type: "üé® Specialty", value: "Reality Designer Master", rarity: "Epic" });
        traits.push({ trait_type: "‚ú® Primary Power", value: "Dimensional Reality Surfing Supreme", rarity: "Legendary" });
      }
      
      // EPIC HYPE Interest-based traits
      if (userInterests.includes("crypto")) {
        traits.push({ trait_type: "üíé Tech Affinity", value: "Blockchain Master Supreme", rarity: "Legendary" });
        traits.push({ trait_type: "‚ö° Secondary Power", value: "Quantum Entanglement Communication Alpha", rarity: "Epic" });
      }
      if (userInterests.includes("science")) {
        traits.push({ trait_type: "üî¨ Scientific Focus", value: "Quantum Research Pioneer Supreme", rarity: "Mythic" });
        traits.push({ trait_type: "‚ö° Equipment", value: "Plasma Energy Generator Master", rarity: "Epic" });
      }
      if (userInterests.includes("tech")) {
        traits.push({ trait_type: "ü§ñ Tech Level", value: "Hyper-Advanced AI Integration Supreme", rarity: "Mythic" });
        traits.push({ trait_type: "üß† Secondary Power", value: "Technological Telepathy Master", rarity: "Legendary" });
      }
      
      // EPIC HYPE Voice/style based traits
      if (userVoice.includes("detailed")) {
        traits.push({ trait_type: "üìä Analysis Style", value: "Deep Data Diver Supreme", rarity: "Epic" });
      }
      if (userVoice.includes("concise")) {
        traits.push({ trait_type: "üí¨ Communication", value: "Quantum Precision Speaker Master", rarity: "Legendary" });
      }
      if (userVoice.includes("curious")) {
        traits.push({ trait_type: "üîç Mindset", value: "Universal Data Stream Seeker Supreme", rarity: "Mythic" });
      }
      
      // EPIC HYPE Ultimate Superpower Traits
      const ultimateSuperpowers = [
        { trait_type: "üî• Quantum Mastery", value: "Quantum Energy Manipulation Supreme", rarity: "Mythic" },
        { trait_type: "üåå Reality Control", value: "Dimensional Reality Surfing Master", rarity: "Mythic" },
        { trait_type: "‚ö° Energy Command", value: "Plasma Energy Generation Alpha", rarity: "Legendary" },
        { trait_type: "üß† Neural Network", value: "Hyper-Advanced AI Integration Supreme", rarity: "Mythic" },
        { trait_type: "üåê Universal Access", value: "Universal Data Stream Access Master", rarity: "Legendary" },
        { trait_type: "üï∞Ô∏è Time Mastery", value: "Temporal Consciousness Access Supreme", rarity: "Mythic" },
        { trait_type: "üîó Quantum Link", value: "Quantum Entanglement Communication Alpha", rarity: "Epic" },
        { trait_type: "üéØ Reality Hack", value: "Reality Data Hacking Master", rarity: "Legendary" },
      ];
      
      // Add ultimate superpowers
      traits.push(...ultimateSuperpowers.slice(0, 4));
      
      // EPIC HYPE Body Background Traits
      const bodyBackgroundTraits = [
        { trait_type: "üåü Primary Enhancement", value: "Quantum Neural Network Integration", rarity: "Mythic" },
        { trait_type: "‚ö° Skin Pattern", value: "Bio-Quantum Circuitry with Plasma Flows", rarity: "Legendary" },
        { trait_type: "üí™ Muscle Evolution", value: "Hyper-Evolved Dimensional Fiber Matrix", rarity: "Epic" },
        { trait_type: "üî• Body Aura", value: "Intense Plasma Energy Field with Quantum Distortions", rarity: "Mythic" },
        { trait_type: "üß¨ Genetic Upgrade", value: "Ultimate DeSci Evolution Level Alpha", rarity: "Mythic" },
        { trait_type: "üõ°Ô∏è Body Armor", value: "Holographic Cyber-Skin with Reality Shields", rarity: "Legendary" },
        { trait_type: "‚ö° Energy Channels", value: "Multi-Dimensional Quantum Energy Conduits", rarity: "Epic" },
        { trait_type: "üí• Physical Power", value: "Dimensional Strength Amplifier with Reality Bending", rarity: "Mythic" },
        { trait_type: "üß† Neural Interface", value: "Hyper-Advanced AI Brain Integration", rarity: "Legendary" },
        { trait_type: "üåå Reality Control", value: "Matrix Reality Manipulation Core", rarity: "Mythic" },
        { trait_type: "‚ö° Energy Mastery", value: "Universal Quantum Energy Command", rarity: "Mythic" },
        { trait_type: "üîÆ Temporal Power", value: "Time-Space Consciousness Access", rarity: "Legendary" },
      ];
      
      // ENHANCED Body Background traits for Profile Picture Users (100000% preservation)
      if (pfpUrl) {
        traits.push(...bodyBackgroundTraits.slice(0, 6)); // More body traits for PFP users
      } else {
        traits.push(...bodyBackgroundTraits.slice(0, 4)); // Standard body traits for text-only
      }
      
      // Base DeSci traits for all users
      traits.push({ trait_type: "Origin", value: "Table d'Adrian DeSci Collective", rarity: "Common" });
      traits.push({ trait_type: "Evolution Level", value: "Hyper-Evolved", rarity: "Legendary" });
      traits.push({ trait_type: "Reality Status", value: "Matrix Controller", rarity: "Mythic" });
      traits.push({ trait_type: "Energy Type", value: "Quantum Plasma", rarity: "Epic" });
      traits.push({ trait_type: "Cyber Enhancement", value: "Neural Quantum Interface", rarity: "Rare" });
      
      return traits;
    };

    const nftTraits = generateTraits();

    // FIXED: 1:1 CHARACTER PRESERVATION PROMPTS
    const characterPreservationPrompt = `CRITICAL: PRESERVE THE ORIGINAL PERSON 100%

üéØ ABSOLUTE CHARACTER PRESERVATION:
- KEEP EXACTLY: Same face, same hair, same skin tone, same facial features
- PRESERVE: Same body type, same clothing style, same colors
- MAINTAIN: Same character identity and appearance
- NO CHANGES: Do not modify the person's face, hair, body, or clothing

üåü ONLY CHANGE THE THEME:
- BACKGROUND: Change to cyberpunk DeSci laboratory/megastructure
- ADD GADGETS: Add cyberpunk DeSci tech accessories and enhancements  
- ATMOSPHERE: Change lighting and environment to cyberpunk DeSci style
- KEEP THE PERSON: Same individual, just in a different setting

üö´ ABSOLUTE PROHIBITIONS:
- NO face changes
- NO hair modifications  
- NO body alterations
- NO clothing changes
- NO character transformation

‚úÖ MANDATORY OUTPUT: Same person in cyberpunk DeSci setting`;

    // Download and process image with maximum error handling
    const downloadAndProcessImage = async (imageUrl: string): Promise<string> => {
      try {
        console.log('Downloading image with maximum error handling:', imageUrl);
        
        const cleanUrl = imageUrl.split('?')[0].split('&')[0];
        
        // Multiple download attempts with different approaches
        const downloadAttempts = [
          {
            headers: {
              'Accept': 'image/*',
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Cache-Control': 'no-cache',
            }
          },
          {
            headers: {
              'Accept': 'image/*',
              'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
              'Cache-Control': 'no-cache',
            }
          },
          {
            headers: {
              'Accept': 'image/jpeg,image/png,image/webp,image/*',
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Cache-Control': 'no-cache',
            }
          }
        ];

        for (let i = 0; i < downloadAttempts.length; i++) {
          try {
            console.log(`Download attempt ${i + 1}`);
            const response = await fetch(cleanUrl, downloadAttempts[i]);

            if (response.ok) {
              const contentType = response.headers.get('content-type') || 'image/jpeg';
              const imageBuffer = await response.arrayBuffer();
              const imageBase64 = Buffer.from(imageBuffer).toString('base64');
              
              console.log('Image downloaded successfully on attempt', i + 1);
              return `data:${contentType};base64,${imageBase64}`;
            }
          } catch (attemptError) {
            console.log(`Download attempt ${i + 1} failed:`, attemptError);
            continue;
          }
        }

        throw new Error('All download attempts failed');
      } catch (error) {
        console.error('Image download completely failed:', error);
        // Return a minimal base64 image as fallback
        return 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k=';
      }
    };

    // IMPROVED: 1:1 CHARACTER PRESERVATION with multiple fallback approaches
    const generateWithCharacterPreservation = async (imageUrl: string, promptText: string): Promise<string> => {
      const approaches = [
        // Approach 1: Pollinations.ai with image-to-image (BEST for character preservation)
        async () => {
          const processedImage = await downloadAndProcessImage(imageUrl);
          const encodedPrompt = encodeURIComponent(promptText);
          const seed = Math.floor(Math.random() * 1000000);
          
          console.log('Using Pollinations.ai with 1:1 character preservation');
          
          // Use Pollinations.ai with image parameter for better character preservation
          const response = await fetch(`https://image.pollinations.ai/prompt/${encodedPrompt}?width=2048&height=2048&model=flux&nologo=true&enhance=true&seed=${seed}&image=${encodeURIComponent(processedImage)}`);
          
          if (response.ok) {
            const generatedImageUrl = response.url;
            if (generatedImageUrl && generatedImageUrl.startsWith('http')) {
              return generatedImageUrl;
            }
          }
          throw new Error('Pollinations.ai image-to-image failed');
        },

        // Approach 2: Pollinations.ai text-to-image with enhanced character description
        async () => {
          console.log('Using Pollinations.ai text-to-image with character description');
          
          // Enhanced prompt that focuses on preserving character while changing theme
          const enhancedPrompt = `${promptText} 

CREATE: Same person from reference image in cyberpunk DeSci setting
PRESERVE: Exact face, hair, skin tone, body type, clothing, colors
CHANGE: Only background to cyberpunk DeSci laboratory/megastructure
ADD: Cyberpunk DeSci tech gadgets and atmospheric lighting
KEEP: Same individual character identity

Style: High quality 2048x2048 anime art with cyberpunk DeSci theme`;
          
          const encodedPrompt = encodeURIComponent(enhancedPrompt);
          const seed = Math.floor(Math.random() * 1000000);
          
          const response = await fetch(`https://image.pollinations.ai/prompt/${encodedPrompt}?width=2048&height=2048&model=flux&nologo=true&enhance=true&seed=${seed}`);
          
          if (response.ok) {
            const generatedImageUrl = response.url;
            if (generatedImageUrl && generatedImageUrl.startsWith('http')) {
              return generatedImageUrl;
            }
          }
          throw new Error('Pollinations.ai text-to-image failed');
        },

        // Approach 3: Try Replicate if available (for face preservation)
        async () => {
          if (!process.env.REPLICATE_API_TOKEN) throw new Error('No Replicate token');
          
          const replicate = new Replicate({ auth: process.env.REPLICATE_API_TOKEN });
          const processedImage = await downloadAndProcessImage(imageUrl);
          
          console.log('Using Replicate for face preservation');
          
          // Try a different Replicate model that might work
          try {
            const output = await replicate.run("stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b", {
              input: {
                image: processedImage,
                prompt: `${promptText} Same person in cyberpunk DeSci setting, preserve exact face and character, change only background and add tech elements`,
                strength: 0.3, // Lower transformation for better preservation
                num_outputs: 1,
                guidance_scale: 7.5,
                num_inference_steps: 50,
              }
            });
            
            if (output && Array.isArray(output) && output[0]) {
              return output[0] as string;
            }
          } catch (replicateErr) {
            console.log('Replicate SDXL failed:', replicateErr);
            throw replicateErr;
          }
          
          throw new Error('Replicate failed');
        },

        // Approach 4: Final fallback with maximum preservation emphasis
        async () => {
          console.log('Using final fallback with maximum character preservation');
          
          const fallbackPrompt = `EXACT CHARACTER PRESERVATION: Same person from reference image

PRESERVE 100%: Same face, hair, skin, body, clothing, colors
CHANGE ONLY: Background to cyberpunk DeSci laboratory
ADD: Cyberpunk DeSci tech gadgets and atmospheric lighting  
KEEP: Same individual character identity

Generate: Same person in cyberpunk DeSci setting, high quality 2048x2048 anime art`;
          
          const encodedPrompt = encodeURIComponent(fallbackPrompt);
          const seed = Math.floor(Math.random() * 1000000);
          
          const response = await fetch(`https://image.pollinations.ai/prompt/${encodedPrompt}?width=2048&height=2048&model=flux&nologo=true&enhance=true&seed=${seed}`);
          
          if (response.ok) {
            const generatedImageUrl = response.url;
            if (generatedImageUrl && generatedImageUrl.startsWith('http')) {
              return generatedImageUrl;
            }
          }
          throw new Error('Final fallback failed');
        }
      ];

      // Try each approach in order
      for (let i = 0; i < approaches.length; i++) {
        try {
          console.log(`Trying approach ${i + 1}/${approaches.length} for character preservation`);
          const result = await approaches[i]();
          if (result && result.startsWith('http')) {
            console.log(`Approach ${i + 1} succeeded with character preservation!`);
            return result;
          }
        } catch (error) {
          console.log(`Approach ${i + 1} failed:`, error);
          continue;
        }
      }

      throw new Error('All character preservation approaches failed');
    };

    console.log('Enhanced cast analysis:', {
      castContext,
      userVoice,
      userInterests,
      userPersonality,
      castsCount: casts?.length || 0,
      bodyTraitsCount: nftTraits.filter(t => t.trait_type.includes('Body') || t.trait_type.includes('Skin') || t.trait_type.includes('Muscle')).length,
    });

    if (pfpUrl) {
      console.log('Generating with 1:1 CHARACTER PRESERVATION:', pfpUrl);
      const cleanPfpUrl = pfpUrl.split('?')[0].split('&')[0];
      const pfpUrlWithCache = `${cleanPfpUrl}?t=${Date.now()}&r=${Math.random()}`;
      
      try {
        nftImageUrl = await generateWithCharacterPreservation(pfpUrlWithCache, characterPreservationPrompt);
        console.log('SUCCESS: Generated with 1:1 CHARACTER PRESERVATION');
      } catch (error) {
        console.log('All approaches failed, trying final fallback');
        // Final fallback - text only with maximum enhancement
        const fallbackPrompt = `${characterPreservationPrompt} FINAL FALLBACK: Same person in cyberpunk DeSci setting, preserve exact character, change only background and theme. High quality 2048x2048 resolution.`;
        const encodedPrompt = encodeURIComponent(fallbackPrompt);
        const seed = Math.floor(Math.random() * 1000000);
        
        const response = await fetch(`https://image.pollinations.ai/prompt/${encodedPrompt}?width=2048&height=2048&model=flux&nologo=true&enhance=true&seed=${seed}`);
        
        if (response.ok) {
          const generatedImageUrl = response.url;
          if (generatedImageUrl && generatedImageUrl.startsWith('http')) {
            nftImageUrl = generatedImageUrl;
            console.log('SUCCESS: Final fallback generation with character preservation');
          } else {
            throw new Error('Final fallback failed');
          }
        } else {
          throw new Error('Final fallback API call failed');
        }
      }
    } else {
      console.log('Generating from scratch with character preservation emphasis');
      try {
        const encodedPrompt = encodeURIComponent(characterPreservationPrompt);
        const seed = Math.floor(Math.random() * 1000000);
        const response = await fetch(`https://image.pollinations.ai/prompt/${encodedPrompt}?width=2048&height=2048&model=flux&nologo=true&enhance=true&seed=${seed}`);
        
        if (response.ok) {
          const generatedImageUrl = response.url;
          if (generatedImageUrl && generatedImageUrl.startsWith('http')) {
            nftImageUrl = generatedImageUrl;
            console.log('SUCCESS: Text-only generation with character preservation');
          } else {
            throw new Error('Text-only generation failed');
          }
        } else {
          throw new Error('Text-only API call failed');
        }
      } catch (pollError) {
        console.log('Text-only generation failed:', pollError);
        throw pollError;
      }
    }

    if (!nftImageUrl || (typeof nftImageUrl === 'string' && nftImageUrl.trim() === '')) {
      console.error('Invalid NFT image URL:', nftImageUrl);
      throw new Error("NFT generation returned no image URL or invalid URL");
    }
    
    if (!nftImageUrl.startsWith('http') && !nftImageUrl.startsWith('data:')) {
      try {
        new URL(nftImageUrl);
      } catch (urlError) {
        console.error('Invalid URL format:', nftImageUrl);
        throw new Error(`NFT generation returned invalid URL format`);
      }
    }

    return NextResponse.json({
      success: true,
      nftImage: nftImageUrl,
      nftMetadata: {
        name: `üöÄ TA NFT: ${username} - 1:1 CHARACTER PRESERVATION CYBERPUNK DeSci ANIME`,
        description: "üî• 1:1 CHARACTER PRESERVATION CYBERPUNK DeSci ANIME NFT! Same person, same face, same character - only background and theme changed! The ultimate cyberpunk DeSci anime protagonist with preserved identity!",
        image: nftImageUrl,
        artist: "Table d'Adrian",
        collection: "TA 1:1 Character Preservation Cyberpunk DeSci Anime Collection",
        traits: nftTraits,
        attributes: nftTraits,
        preservationLevel: "1:1 CHARACTER PRESERVATION - Same face, same character, same identity (100%)",
        characterPreserved: "1:1: Same person, same face, same character, same clothing - only theme changed",
        bodyEnhancements: "Bio-Quantum Circuitry, Holographic Cyber-Skin (1:1 Character Preservation)",
        superpowerLevel: "SUPREME - All 10 ultimate cyberpunk DeSci powers (Same Character)",
        hypeLevel: "1:1 CHARACTER PRESERVATION - High quality 2048x2048 same person cyberpunk DeSci anime NFT",
        background: "Cyberpunk DeSci megastructure (1:1 Character Preservation Background)",
        style: "1:1 CHARACTER PRESERVATION CYBERPUNK DeSci ANIME - 2048x2048 resolution",
        composition: "1:1 CHARACTER PRESERVATION same person from head to toe - same face, same character",
        requirementsLevel: "1:1 CHARACTER PRESERVATION - Same person, same character, same identity - only theme changed",
      },
    });
  } catch (error: any) {
    console.error("NFT generation error:", error);
    const errorMessage = error instanceof Error ? error.message : (error?.message || String(error));
    const errorDetails = error instanceof Error ? error.stack : (error?.stack || String(error));
    console.error("Error details:", errorDetails);
    console.error("Full error object:", JSON.stringify(error, null, 2));
    
    let userMessage = "Failed to generate NFT. Please try again.";
    if (errorMessage.includes("timeout") || errorMessage.includes("time") || errorMessage.includes("504")) {
      userMessage = "Generation timed out. The AI model may be busy. Please try again in a moment.";
    } else if (errorMessage.includes("invalid URL") || errorMessage.includes("no image URL")) {
      userMessage = "Failed to generate a valid image. Please ensure your profile picture is accessible.";
    } else if (errorMessage) {
      userMessage = `Generation failed: ${errorMessage}`;
    }
    
    return NextResponse.json(
      { 
        error: "Generation failed",
        details: errorMessage,
        message: userMessage,
        fullError: process.env.NODE_ENV === 'development' ? errorDetails : undefined
      },
      { status: 500 }
    );
  }
